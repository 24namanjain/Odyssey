{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Odyssey Documentation","text":"<p>This documentation contains notes and guides covering various technologies including Java, Spring Boot, and Kubernetes.</p>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"<ul> <li>Java - Java programming language notes and best practices</li> <li>Spring Boot - Spring Boot framework documentation</li> <li>Kubernetes - Kubernetes deployment and management guides</li> </ul>"},{"location":"#getting-started","title":"Getting Started","text":"<p>To work with this documentation locally:</p> <ul> <li><code>mkdocs serve</code> - Start a local docs server with live-reloading</li> <li><code>mkdocs build</code> - Build the static documentation site</li> <li><code>mkdocs -h</code> - Show help options</li> </ul>"},{"location":"#documentation-structure","title":"Documentation Structure","text":"<pre><code>docs/\n    index.md              # This welcome page\n    java-notes.md         # Java documentation\n    spring-boot-notes.md  # Spring Boot documentation \n    kubernetes-notes.md   # Kubernetes documentation\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>Feel free to contribute to this documentation by submitting pull requests or opening issues if you find any errors or have suggestions for improvements.</p>"},{"location":"Docker/notes/1-docker-introduction/","title":"Docker Introduction","text":"<p>Docker is a platform that enables developers to create, deploy, and run applications in containers. Containers are lightweight, portable, and self-sufficient units that include everything needed to run a piece of software, including the code, runtime, system tools, libraries, and settings.</p>"},{"location":"Docker/notes/1-docker-introduction/#benefits-of-docker","title":"Benefits of Docker","text":"<ol> <li>Portability: Docker containers can run on any system that supports Docker, ensuring consistency across multiple environments.</li> <li>Scalability: Easily scale applications up or down by adding or removing containers.</li> <li>Isolation: Containers run in isolation from each other, ensuring that dependencies and configurations do not conflict.</li> <li>Efficiency: Containers share the host system's kernel, making them more lightweight and faster to start compared to traditional virtual machines.</li> <li>Version Control: Docker images can be versioned, allowing developers to track changes and roll back to previous versions if needed.</li> </ol>"},{"location":"Docker/notes/1-docker-introduction/#how-docker-works","title":"How Docker Works","text":"<ol> <li>Dockerfile: Developers write a Dockerfile, which contains a set of instructions to build a Docker image.</li> <li>Docker Image: The Dockerfile is used to create a Docker image, which is a snapshot of the application and its dependencies.</li> <li>Docker Container: A running instance of a Docker image is called a container. Containers can be started, stopped, and managed using Docker commands.</li> <li>Docker Hub: A cloud-based registry service where Docker images can be stored, shared, and downloaded.</li> </ol> <p>By using Docker, developers can ensure that their applications run consistently across different environments, streamline the development process, and improve deployment efficiency.</p>"},{"location":"Docker/notes/2-docker-basic-commands/","title":"Docker Basic Commands","text":""},{"location":"Docker/notes/2-docker-basic-commands/#pulling-and-running-postgresql","title":"Pulling and Running PostgreSQL","text":"<pre><code>docker run postgres:17.2\n# Unable to find image 'postgres:17.2' locally\n# Pulling the image from Docker Hub\n# Error: Database is uninitialized and superuser password is not specified\n\ndocker run -e POSTGRES_PASSWORD=admin postgres:17.2\n# Successfully initializes and starts PostgreSQL\n</code></pre>"},{"location":"Docker/notes/2-docker-basic-commands/#running-postgresql-in-detached-mode","title":"Running PostgreSQL in Detached Mode","text":"<pre><code>docker run -d -e POSTGRES_PASSWORD=admin postgres:17.2\n# Runs PostgreSQL in detached mode\n</code></pre>"},{"location":"Docker/notes/2-docker-basic-commands/#pulling-redis-image","title":"Pulling Redis Image","text":"<pre><code>docker pull redis\n# Pulls the latest Redis image from Docker Hub\n</code></pre>"},{"location":"Docker/notes/2-docker-basic-commands/#listing-all-containers","title":"Listing All Containers","text":"<pre><code>docker ps -a\n# Lists all containers, including stopped ones\n</code></pre>"},{"location":"Docker/notes/2-docker-basic-commands/#listing-docker-images","title":"Listing Docker Images","text":"<pre><code>docker images\n# Lists all Docker images\n</code></pre>"},{"location":"Docker/notes/2-docker-basic-commands/#running-redis","title":"Running Redis","text":"<pre><code>docker run redis:7.4.2\n# Pulls and runs Redis version 7.4.2\n\ndocker run -d redis:7.4.2\n# Runs Redis in detached mode\n\ndocker run -p6000:6379 -d redis\n# Runs Redis and maps port 6000 on the host to port 6379 in the container\n\ndocker run -p6001:6379 -d redis:7.4.2\n# Runs Redis version 7.4.2 and maps port 6001 on the host to port 6379 in the container\n</code></pre>"},{"location":"Docker/notes/2-docker-basic-commands/#stopping-and-starting-containers","title":"Stopping and Starting Containers","text":"<pre><code>docker stop &lt;container_id&gt;\n# Stops a running container\n\ndocker start &lt;container_id&gt;\n# Starts a stopped container\n</code></pre>"},{"location":"Docker/notes/2-docker-basic-commands/#removing-containers","title":"Removing Containers","text":"<p>```bash docker rm"},{"location":"Docker/notes/2-docker-basic-commands/#removes-a-stopped-container","title":"Removes a stopped container","text":""},{"location":"Docker/notes/3-debugging-a-container/","title":"Debugging a Docker Container","text":""},{"location":"Docker/notes/3-debugging-a-container/#listing-running-containers","title":"Listing Running Containers","text":"<pre><code>docker ps\n# Lists all running containers\n</code></pre>"},{"location":"Docker/notes/3-debugging-a-container/#viewing-logs-of-a-container","title":"Viewing Logs of a Container","text":"<pre><code>docker logs 4e581427f272\n# Displays logs for the container with ID 4e581427f272\n</code></pre>"},{"location":"Docker/notes/3-debugging-a-container/#stopping-a-container","title":"Stopping a Container","text":"<pre><code>docker stop 4e581427f272\n# Stops the container with ID 4e581427f272\n</code></pre>"},{"location":"Docker/notes/3-debugging-a-container/#running-an-older-version-of-redis","title":"Running an Older Version of Redis","text":"<pre><code>docker run -d -p6001:6379 --name redis-older redis:4.0\n# Runs Redis version 4.0 in detached mode and maps port 6001 on the host to port 6379 in the container\n</code></pre>"},{"location":"Docker/notes/3-debugging-a-container/#viewing-logs-of-the-new-container","title":"Viewing Logs of the New Container","text":"<pre><code>docker logs redis-older\n# Displays logs for the container named redis-older\n</code></pre>"},{"location":"Docker/notes/3-debugging-a-container/#executing-commands-inside-a-running-container","title":"Executing Commands Inside a Running Container","text":"<pre><code>docker exec -it dee2f89027e3 /bin/bash\n# Opens a bash shell inside the container with ID dee2f89027e3\n\n# Inside the container\nls\n# Lists files and directories in the current directory\n\npwd\n# Prints the current working directory\n\ncd ~\n# Changes to the home directory\n\ncd /\n# Changes to the root directory\n\nls\n# Lists files and directories in the root directory\n\nenv\n# Displays environment variables\n</code></pre>"},{"location":"Kubernetes/notes/1-kubernetes-introduction/","title":"Kubernetes Introduction","text":"<p>Kubernetes is an open-source platform designed to automate deploying, scaling, and operating application containers. It groups containers that make up an application into logical units for easy management and discovery.</p>"},{"location":"Kubernetes/notes/1-kubernetes-introduction/#key-concepts","title":"Key Concepts","text":"<ol> <li>Cluster: A set of nodes (physical or virtual machines) that run containerized applications managed by Kubernetes.</li> <li>Node: A single machine in a Kubernetes cluster, which can be either a physical or virtual machine.</li> <li>Pod: The smallest and simplest Kubernetes object. A pod represents a single instance of a running process in a cluster and can contain one or more containers.</li> <li>Service: An abstraction that defines a logical set of pods and a policy by which to access them.</li> <li>Deployment: A controller that provides declarative updates to applications. It manages the deployment of pods and ensures the desired number of replicas are running.</li> </ol>"},{"location":"Kubernetes/notes/1-kubernetes-introduction/#benefits-of-kubernetes","title":"Benefits of Kubernetes","text":"<ol> <li>Scalability: Automatically scale applications up or down based on demand.</li> <li>Portability: Run applications consistently across different environments.</li> <li>High Availability: Ensure applications are always running and available.</li> <li>Resource Efficiency: Optimize the use of resources by managing containerized applications efficiently.</li> <li>Self-Healing: Automatically replace or reschedule containers that fail, are terminated, or are unresponsive.</li> </ol>"},{"location":"Kubernetes/notes/1-kubernetes-introduction/#how-kubernetes-works","title":"How Kubernetes Works","text":"<ol> <li>Kubernetes Master: The control plane that manages the cluster. It consists of components like the API server, scheduler, and controller manager.</li> <li>Kubelet: An agent that runs on each node in the cluster and ensures containers are running in a pod.</li> <li>kubectl: A command-line tool for interacting with the Kubernetes API server and managing Kubernetes resources.</li> </ol> <p>By using Kubernetes, developers can deploy and manage applications at scale, ensuring high availability and efficient use of resources.</p>"},{"location":"Kubernetes/notes/2-main-kube-components/","title":"Main Kubernetes Components","text":""},{"location":"Kubernetes/notes/2-main-kube-components/#node","title":"Node","text":"<ul> <li>A Node is a server in the Kubernetes cluster.</li> <li>It can be a physical or virtual machine.</li> <li>Each node runs pods and is managed by the Kubernetes master.</li> <li>Nodes contain the necessary services to run pods and are responsible for maintaining the running pods.</li> </ul>"},{"location":"Kubernetes/notes/2-main-kube-components/#pod","title":"Pod","text":"<ul> <li>A Pod is the smallest and simplest Kubernetes object.</li> <li>It represents a single instance of a running process in the cluster and can contain one or more containers.</li> <li>Each pod gets its own IP address, and when a pod is re-created, it gets a new IP address.</li> <li>Pods are ephemeral and can be replaced by new pods if they fail or are terminated.</li> </ul>"},{"location":"Kubernetes/notes/2-main-kube-components/#service","title":"Service","text":"<ul> <li>A Service provides a permanent IP address and DNS name for a set of pods.</li> <li>It acts as an abstraction layer that defines a logical set of pods and a policy by which to access them.</li> <li>The lifecycle of a service is not connected with the lifecycle of the pods it targets, ensuring a stable network endpoint for accessing the pods.</li> </ul>"},{"location":"Kubernetes/notes/2-main-kube-components/#ingress","title":"Ingress","text":"<ul> <li>An Ingress is an API object that manages external access to services within a cluster, typically HTTP.</li> <li>Ingress can provide load balancing, SSL termination, and name-based virtual hosting.</li> <li>It allows you to define rules for routing traffic to different services based on the URL path or host.</li> </ul>"},{"location":"Kubernetes/notes/2-main-kube-components/#configmap","title":"ConfigMap","text":"<ul> <li>A ConfigMap is used to store external configuration of the application.</li> <li>It allows you to decouple configuration artifacts from image content to keep containerized applications portable.</li> </ul>"},{"location":"Kubernetes/notes/2-main-kube-components/#secret","title":"Secret","text":"<ul> <li>A Secret is used to store secret data, such as passwords, OAuth tokens, and SSH keys.</li> <li>The data is base64 encoded and can be mounted as files or exposed as environment variables in a pod.</li> </ul>"},{"location":"Kubernetes/notes/2-main-kube-components/#volume","title":"Volume","text":"<ul> <li>A Volume attaches a physical storage which can be either on a local machine or outside of the Kubernetes cluster.</li> <li>Volumes allow data to persist across pod restarts and can be shared between containers in the same pod.</li> <li>Different types of volumes are available, such as <code>emptyDir</code>, <code>hostPath</code>, <code>persistentVolumeClaim</code>, and more, each with its own use case and characteristics.</li> <li>Volumes are defined in the pod specification and are mounted into the containers at specified paths.</li> </ul>"},{"location":"Kubernetes/notes/2-main-kube-components/#deployment","title":"Deployment","text":"<ul> <li>A Deployment is used to manage stateless applications.</li> <li>It provides declarative updates to applications and ensures that the desired number of pod replicas are running.</li> <li>Deployments allow you to roll out updates, roll back to previous versions, and scale the number of replicas easily.</li> </ul>"},{"location":"Kubernetes/notes/2-main-kube-components/#statefulset","title":"StatefulSet","text":"<ul> <li>A StatefulSet is used to manage stateful applications or databases.</li> <li>It ensures that each pod has a unique, stable network identity and persistent storage.</li> <li>StatefulSets maintain the order and uniqueness of pods, which is crucial for applications that require stable, persistent storage and ordered deployment and scaling.</li> <li>They are typically used for applications like databases, where the state needs to be preserved across pod restarts and rescheduling.</li> </ul>"},{"location":"Kubernetes/notes/3-k8s-architecture/","title":"Kubernetes Node Architecture","text":"<p>Each node has multiple pods.</p>"},{"location":"Kubernetes/notes/3-k8s-architecture/#essential-components-required-for-a-kubernetes-node","title":"Essential Components Required for a Kubernetes Node:","text":"<ol> <li>Container Runtime: The software that is responsible for running containers.</li> <li>Kubelet: Interacts with both the container and the node to ensure that containers are running in a pod.</li> <li>Kube Proxy: Forwards the request to the appropriate pod or service.</li> </ol>"},{"location":"Kubernetes/notes/3-k8s-architecture/#master-processes","title":"Master Processes","text":"<p>Four processes run on every master node:</p> <ol> <li>API Server: Acts as the cluster gateway, receiving requests for cluster changes such as deployments. It validates and authenticates the requests.</li> <li>Scheduler: Determines on which node a pod should be placed.</li> <li>Controller Manager: Detects changes in the cluster state, such as when pods die, and requests the scheduler to take action.</li> <li>etcd: A key-value store that acts as the cluster's brain. Cluster changes are stored here. The scheduler checks it for available resources, and the controller manager uses it for cluster data. It does not store application data.</li> </ol>"},{"location":"Kubernetes/notes/3-k8s-architecture/#component-planes-in-kubernetes","title":"Component Planes in Kubernetes","text":"<p>Kubernetes components can be categorized into two main planes:</p> <ol> <li>Control Plane (Master Components):</li> <li>Contains the master processes (API Server, Scheduler, Controller Manager, etcd)</li> <li>Acts as the brain of the cluster</li> <li>Users and administrators interact with this plane through kubectl or API</li> <li>Makes global decisions about the cluster</li> <li> <p>Handles orchestration and management</p> </li> <li> <p>Compute Plane (Worker Components):</p> </li> <li>Contains the worker node components (Container Runtime, Kubelet, Kube Proxy)</li> <li>Runs the actual workloads</li> <li>Never interacted with directly by users</li> <li>Receives instructions from Control Plane</li> <li>Executes the actual container operations</li> </ol> <p>This architecture ensures a clear separation of concerns, where users only need to interact with the Control Plane, which then manages and coordinates with the Compute Plane components.</p>"},{"location":"Kubernetes/notes/4-local-k8s-setup/","title":"Local Kubernetes Setup with Minikube","text":""},{"location":"Kubernetes/notes/4-local-k8s-setup/#prerequisites","title":"Prerequisites","text":"<p>Install Hyperkit and Minikube using Homebrew:</p> <pre><code>brew install hyperkit\nbrew install minikube\n</code></pre>"},{"location":"Kubernetes/notes/4-local-k8s-setup/#starting-minikube","title":"Starting Minikube","text":"<p>Start Minikube with the following command:</p> <pre><code>minikube start\n</code></pre> <p>Example output:</p> <pre><code>\ud83d\ude04  minikube v1.34.0 on Darwin 15.0.1 (arm64)\n\u2728  Automatically selected the docker driver. Other choices: ssh, podman (experimental), vfkit (experimental)\n\ud83d\udccc  Using Docker Desktop driver with root privileges\n\ud83d\udc4d  Starting \"minikube\" primary control-plane node in \"minikube\" cluster\n\ud83d\ude9c  Pulling base image v0.0.45 ...\n\ud83d\udcbe  Downloading Kubernetes v1.31.0 preload ...\n    &gt; preloaded-images-k8s-v18-v1...:  307.61 MiB / 307.61 MiB  100.00% 9.50 Mi\n    &gt; gcr.io/k8s-minikube/kicbase...:  441.45 MiB / 441.45 MiB  100.00% 12.26 M\n\ud83d\udd25  Creating docker container (CPUs=2, Memory=4000MB) ...\n\ud83d\udc33  Preparing Kubernetes v1.31.0 on Docker 27.2.0 ...\n    \u25aa Generating certificates and keys ...\n    \u25aa Booting up control plane ...\n    \u25aa Configuring RBAC rules ...\n\ud83d\udd17  Configuring bridge CNI (Container Networking Interface) ...\n\ud83d\udd0e  Verifying Kubernetes components...\n    \u25aa Using image gcr.io/k8s-minikube/storage-provisioner:v5\n\ud83c\udf1f  Enabled addons: default-storageclass, storage-provisioner\n\ud83c\udfc4  Done! kubectl is now configured to use \"minikube\" cluster and \"default\" namespace by default\n</code></pre> <p>Check the status of Minikube:</p> <pre><code>minikube status\n</code></pre> <p>Example output:</p> <pre><code>minikube\ntype: Control Plane\nhost: Running\nkubelet: Running\napiserver: Running\nkubeconfig: Configured\n</code></pre>"},{"location":"Kubernetes/notes/4-local-k8s-setup/#using-kubectl","title":"Using kubectl","text":"<p>Check the Kubernetes version:</p> <pre><code>kubectl version\n</code></pre> <p>Example output:</p> <pre><code>Client Version: v1.31.1\nKustomize Version: v5.4.2\nServer Version: v1.31.0\n</code></pre> <p>Check for existing pods and services:</p> <pre><code>kubectl get pod\nkubectl get services\n</code></pre> <p>Example output:</p> <pre><code>No resources found in default namespace.\n\nNAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE\nkubernetes   ClusterIP   10.96.0.1    &lt;none&gt;        443/TCP   5m12s\n</code></pre>"},{"location":"Kubernetes/notes/4-local-k8s-setup/#creating-a-deployment","title":"Creating a Deployment","text":"<p>Create a deployment using the <code>nginx</code> image:</p> <pre><code>kubectl create deployment nginx-delp --image=nginx\n</code></pre> <p>Example output:</p> <pre><code>deployment.apps/nginx-delp created\n</code></pre> <p>Check the deployment status:</p> <pre><code>kubectl get deployment\n</code></pre> <p>Example output:</p> <pre><code>NAME         READY   UP-TO-DATE   AVAILABLE   AGE\nnginx-depl   1/1     1            1           6s\n</code></pre> <p>Check the replicaset:</p> <pre><code>kubectl get replicaset\n</code></pre> <p>Example output:</p> <pre><code>NAME                    DESIRED   CURRENT   READY   AGE\nnginx-depl-5796b5c499   1         1         1       9d\n</code></pre> <p>Check the pod status:</p> <pre><code>kubectl get pod\n</code></pre> <p>Example output:</p> <pre><code>NAME                          READY   STATUS         RESTARTS   AGE\nnginx-delp-69499d958c-bj76r   0/1     ErrImagePull   0          15s\n</code></pre>"},{"location":"Kubernetes/notes/4-local-k8s-setup/#deleting-a-deployment","title":"Deleting a Deployment","text":"<p>Delete the deployment:</p> <pre><code>kubectl delete deployment nginx-delp\n</code></pre> <p>Example output:</p> <pre><code>deployment.apps \"nginx-delp\" deleted\n</code></pre> <p>Recreate the deployment with the correct image:</p> <pre><code>kubectl create deployment nginx-delp --image=nginx\n</code></pre> <p>Example output:</p> <pre><code>deployment.apps/nginx-delp created\n</code></pre> <p>Check the replicaset again:</p> <pre><code>kubectl get replicaset\n</code></pre> <p>Example output:</p> <pre><code>NAME                    DESIRED   CURRENT   READY   AGE\nnginx-depl-5796b5c499   1         1         1       9d\n</code></pre>"},{"location":"Kubernetes/notes/5-basic-kubectl-commands/","title":"Basic Commands","text":"<pre><code>kubectl create deployment nginx-depl --image=nginx\ndeployment.apps/nginx-depl created\n\nkubectl get pod  \nNAME                          READY   STATUS    RESTARTS     AGE\nnginx-depl-5796b5c499-2rhcn   1/1     Running   1 (6d ago)   9d\n\n# \nkubectl get replicaset\nNAME                    DESIRED   CURRENT   READY   AGE\nnginx-depl-5796b5c499   1         1         1       9d\n\nkubectl delete deployment nginx-depl              \ndeployment.apps \"nginx-depl\" deleted\n\nkubectl create deployment nginx-depl --image=nginx\ndeployment.apps/nginx-depl created\n</code></pre> <ol> <li>CRUD commands</li> </ol> <pre><code>kubectl create deployment [name]\n\nkubectl edit deployment [name]\n\nkubectl delete deployment [name]\n</code></pre> <ol> <li>Status of different K8s components</li> </ol> <pre><code>kubectl get nodes | pod | services | replicaset | deployment\n</code></pre> <ol> <li> <p>Debugging pods</p> <ol> <li>Logs to console</li> </ol> <p><code>bash kubectl logs [pod name]</code></p> <ol> <li>Get interactive terminal</li> </ol> <p>```bash kubectl exec -it [pod name] -- /bin/bash</p> <p>kubectl exec -it nginx-depl-85db6bcdc5-c28d8 -- /bin/bash ```</p> </li> </ol>"},{"location":"Kubernetes/notes/5-basic-kubectl-commands/#example","title":"Example","text":"<pre><code>&gt; kubectl create deployment nginx-depl --image=nginx\ndeployment.apps/nginx-depl created\n\n&gt; kubectl get pods\nNAME                          READY   STATUS    RESTARTS   AGE\nnginx-depl-85db6bcdc5-c28d8   1/1     Running   0          19s\n\n&gt; kubectl logs nginx-depl-85db6bcdc5-c28d8\n/docker-entrypoint.sh: /docker-entrypoint.d/ is not empty, will attempt to perform configuration\n\n&gt; kubectl exec -it nginx-depl-85db6bcdc5-c28d8 -- /bin/bash\nroot@nginx-depl-85db6bcdc5-c28d8:/# who\nroot@nginx-depl-85db6bcdc5-c28d8:/# whoami\nroot\n\n&gt; kubectl get replicaset\nNAME                    DESIRED   CURRENT   READY   AGE\nnginx-depl-85db6bcdc5   1         1         1       5m51s\n\n&gt; kubectl get deployment\nNAME         READY   UP-TO-DATE   AVAILABLE   AGE\nnginx-depl   1/1     1            1           6m30s\n\n&gt; kubectl get pod\nNAME                          READY   STATUS    RESTARTS        AGE\nnginx-depl-85db6bcdc5-c28d8   1/1     Running   1 (4m22s ago)   6m45s\n\n&gt; kubectl delete deployment ngnix-depl\nError from server (NotFound): deployments.apps \"ngnix-depl\" not found\n\n&gt; kubectl delete deployment ngnix-depl\nError from server (NotFound): deployments.apps \"ngnix-depl\" not found\n\n&gt; kubectl get deployment              \nNAME         READY   UP-TO-DATE   AVAILABLE   AGE\nnginx-depl   1/1     1            1           25m\n\n&gt; kubectl delete deployment nginx-depl\ndeployment.apps \"nginx-depl\" deleted\n</code></pre>"},{"location":"Kubernetes/notes/5-basic-kubectl-commands/#layers-of-abstraction","title":"Layers of Abstraction","text":"<ol> <li> <p>Deployment manages a</p> <ul> <li>ReplicaSet</li> </ul> </li> <li> <p>ReplicaSet manages a</p> <ul> <li>Pod</li> </ul> </li> <li> <p>Pod is an abstraction of</p> <ul> <li>Container</li> </ul> </li> </ol> <pre><code>4. Editing a deployment\n\n```bash\nkubectl edit deployment nginx-depl\n</code></pre> <p>If we edit, the existing pod is terminated and a new pod is created as soon as we save.</p> <pre><code>\n### Pod Monitoring\n\n1. Describe a pod\n\n```bash\nkubectl describe pod [pod name]\n\nkubectl describe pod nginx-depl-6f7f5bff95-5ttr6\n</code></pre> <ol> <li>View logs of a pod</li> </ol> <pre><code>kubectl logs [pod name]\n\nkubectl logs nginx-depl-6f7f5bff95-5ttr6\n</code></pre>"},{"location":"Kubernetes/notes/5-basic-kubectl-commands/#get-terminal-of-the-pod","title":"Get Terminal of the Pod","text":"<pre><code>kubectl exec -it nginx-depl-6f7f5bff95-5ttr6 -- /bin/bash\n</code></pre> <p>Odyssey &gt; kubectl exec -it nginx-depl-6f7f5bff95-5ttr6 -- /bin/bash root@nginx-depl-6f7f5bff95-5ttr6:/# ls bin   dev                  docker-entrypoint.sh  home  media  opt   root  sbin  sys  usr boot  docker-entrypoint.d  etc                   lib   mnt    proc  run   srv   tmp  var root@nginx-depl-6f7f5bff95-5ttr6:/#</p>"},{"location":"Kubernetes/notes/5-basic-kubectl-commands/#get-rid-of-the-pod","title":"Get Rid of the Pod","text":"<pre><code>kubectl delete deployment &lt;deployment-name&gt;\n</code></pre> <pre><code>Odyssey &gt; kubectl delete deployment nginx-depl\ndeployment.apps \"nginx-depl\" deleted\n\nOdyssey &gt; kubectl get pods                    \nNo resources found in default namespace.\n</code></pre>"},{"location":"Kubernetes/notes/5-basic-kubectl-commands/#apply-configuration-file","title":"Apply Configuration File","text":"<ol> <li>Apply a configuration file</li> </ol> <pre><code>kubectl apply -f nginx-deployment.yaml\ndeployment.apps/nginx-deployment created\n</code></pre> <ol> <li>Check the deployment status</li> </ol> <pre><code>kubectl get deployment\nNAME               READY   UP-TO-DATE   AVAILABLE   AGE\nnginx-deployment   1/1     1            1           27s\n</code></pre> <ol> <li>Edit the configuration file</li> </ol> <pre><code>vi nginx-deployment.yaml\n</code></pre> <ol> <li>Re-apply the configuration file</li> </ol> <pre><code>kubectl apply -f nginx-deployment.yaml\ndeployment.apps/nginx-deployment configured\n</code></pre> <ol> <li>Verify the updated deployment status</li> </ol> <pre><code>kubectl get deployment                \nNAME               READY   UP-TO-DATE   AVAILABLE   AGE\nnginx-deployment   2/2     2            2           56s\n</code></pre> <p>You can find the <code>nginx-deployment.yaml</code> file in the same directory here.</p>"},{"location":"Kubernetes/notes/6-control-plane-components/","title":"Control Plane Components","text":""},{"location":"Kubernetes/notes/6-control-plane-components/#api-server-kube-apiserver","title":"API Server (kube-apiserver)","text":"<p>The API Server is the primary control plane component that exposes the Kubernetes API. It acts as the front-end for the Kubernetes control plane and is designed to scale horizontally.</p> <p>Key characteristics: - Entry point for all REST commands used to control the cluster - Can be accessed through:   - kubectl CLI tool   - Direct API calls   - Kubernetes Dashboard (Web UI) - Validates and processes API requests - Serves as the gateway to the cluster - Responsible for:   - Authentication   - Authorization   - Request validation   - API object manipulation (CRUD operations)</p>"},{"location":"Kubernetes/notes/6-control-plane-components/#etcd","title":"etcd","text":"<p>etcd is a distributed key-value store that serves as the cluster's primary datastore:</p> <p>Key aspects: - Stores all cluster configuration data and state - Acts as the single source of truth for the cluster - All cluster changes are persisted here - Can only be accessed through the API server - Deployment options:   - Co-located with kube-apiserver (simpler setup)   - As a separate external cluster (more complex but better for production)</p> <p>The API server is the only component that directly communicates with etcd, ensuring: - Consistent data access patterns - Data integrity and security - Proper authentication and authorization</p>"},{"location":"Kubernetes/notes/6-control-plane-components/#scheduler-kube-scheduler","title":"Scheduler (kube-scheduler)","text":"<p>The Scheduler is responsible for assigning newly created pods to worker nodes in the cluster.</p> <p>Key responsibilities: - Monitors for unscheduled pods - Selects optimal nodes for pod placement - Updates pod configuration with node assignment</p> <p>Scheduling process: 1. New pods are created without node assignments (unscheduled state) 2. Pod information is stored in etcd without a nodeName property 3. Scheduler continuously monitors API server for unscheduled pods 4. When found, scheduler selects an appropriate worker node 5. Updates the pod's nodeName property to mark it as scheduled</p> <p>Deployment considerations: - Should be deployed on highly available nodes - Often co-located with other control plane components like kube-apiserver - Critical for efficient cluster resource utilization</p>"},{"location":"Kubernetes/notes/6-control-plane-components/#controller-manager-kube-controller-manager","title":"Controller Manager (kube-controller-manager)","text":"<p>The Controller Manager is a core component that manages the cluster's state and ensures the desired state is maintained:</p> <p>Key responsibilities: - Manages the lifecycle of various Kubernetes resources - Ensures the desired state is maintained - Handles resource allocation and management - Manages node and pod health - Implements various controllers (e.g., Node Controller, Job Controller, Endpoint Controller)</p> <p>Deployment considerations: - Should be deployed on highly available nodes - Often co-located with other control plane components like kube-apiserver - Handles resource allocation and management - Manages node and pod health - Implements various controllers (e.g., Node Controller, Job Controller, Endpoint Controller)</p>"},{"location":"Kubernetes/notes/6-control-plane-components/#cloud-controller-manager-cloud-controller-manager","title":"Cloud Controller Manager (cloud-controller-manager)","text":"<p>The Cloud Controller Manager is a specialized component that manages cloud-specific resources:</p> <p>Key responsibilities: - Manages cloud-specific resources (e.g., load balancers, storage, and network) - Interfaces with cloud provider APIs - Handles resource allocation and management - Manages node and pod health - Implements various controllers (e.g., Node Controller, Job Controller, Endpoint Controller)</p> <p>Deployment considerations: - Should be deployed on highly available nodes - Often co-located with other control plane components like kube-apiserver - Handles resource allocation and management - Manages node and pod health</p>"},{"location":"Kubernetes/notes/6-control-plane-components/#summary","title":"Summary","text":"<p>The Kubernetes control plane consists of five main components:</p> <ol> <li>API Server: The gateway to the cluster, handling all API requests and authentication</li> <li>etcd: The distributed database storing all cluster state and configuration</li> <li>Scheduler: Assigns pods to nodes based on resource requirements and constraints</li> <li>Controller Manager: Maintains desired state and manages various controllers</li> <li>Cloud Controller Manager: Handles cloud-provider specific resources and integration</li> </ol> <p>These components work together to: - Maintain cluster state - Handle scheduling and resource allocation - Manage cloud provider integration - Ensure high availability and scalability - Provide a unified API interface for cluster management</p>"}]}